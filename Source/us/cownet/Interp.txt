:P >r
:P pick
: dup 1 pick ;
:P @
:P rot
: swap 1 rot ;
:P +
:P r>
:P compileTOS()
: compile: >r dup @ swap 1 + r> compileTOS() ;
:P compilerPosition()
:I while: compilerPosition() ;
:P (JMP_IF_FALSE)
:P (NOP)
:I do compile: (JMP_IF_FALSE) compilerPosition() compile: (NOP) ;
:P (JMP)
: compileJumpTo()           // where to jump to ---
    compile: (JMP) compilerPosition() 1 + - compileTOS()
;
: compileJumpFrom()                // where to jump from to current pos
    dup compilerPosition() swap - swap !
;
:I :while   // whilePos exitJmpPos
    swap    // exitJmpPos whilePos
    compileJumpTo()     // jump to while condition
    compileJumpFrom()   // jump from jmp-if-false
;
:I if:
     compile: JMP_IF_FALSE
;
:I :if
    compileJumpFrom()   // jump from jmp-if-false
;
:I :else:
    compile: (JMP)
    compilerPosition()
    compile: (NOP)
    swap
    compileJumpFrom()
;
:P :char
:P :word
:P :c[]
:P :w[]
:P !           // addr val --
:P c!          // addr val --
:P @           // addr -- val
:P c@          // addr -- val
:P accept()    // addr len --
:P tokenize()  // addr val --
:P print()     // addr --
:P println()   // addr --
:P evaluate()  // addr --
:P parseNumber()   // str -- value 1 or 0
:P find()      // strAddr -- word bool 1 or 0
:P beginCompileNewWord()            //  strAddr --
:P endCompileNewWord()
:P abortCompileNewWord()
:P parseString()
:P clearTib()

-----------------------------
:c[] tib 256 ;
tib 0 c!
:word token ;
:char keepRunningCommandLineInterp ;
keepRunningCommandLineInterp 1 c!

/* return the length of a null terminated string */
: strLength() // addr -- length
	dup
	while: dup c@ != 0 do
		1 +
	:while
	swap -
;

: nextToken()
    token ((token @) + (token @ strLength())) !
;

: MAX_INPUT_LENGTH 255 ;

: readTokens()
	tib MAX_INPUT_LENGTH accept()
	tib 32 tokenize()
	token tib !
;

: clearTib()
    tib 0 c!
    token tib !
;

: commandLineInterp
    while: keepRunningCommandLineInterp @ do
        token @ strLength() == 0 if:
			readTokens()
		:if
		token @ find() if:
			nextToken()
		    drop
			evaluate()
		:else:
			parseNumber() if:
				nextToken()
			:else:
				token @ print()
				" ?" println()
				clearTib()
			:if
		:if
	:while
;

: :
    0
    compileWord();
;

: :I
    1
    compileWord()
;

:P (PUSH_NEXT_INSTRUCTION_WORD_AS_DATA)
: compileWord
    beginCompileNewWord()
    nextToken()
    while: token @ c@ do
        token @ find() if:
            if: //immediate word
                evaluate();
            :else:
                compileTOS()
            :if
        :else:
            token @ parseNumber() if:
                compile: (PUSH_NEXT_INSTRUCTION_WORD_AS_DATA)
                compileTOS()
            :else:
                token @ parseString() if:
                    compile: (PUSH_NEXT_INSTRUCTION_WORD_AS_DATA)
                    compileTOS()
                :else:
                    // word not a literal or found in dictionary
                    token @ print()
                    " ?" println()
                    clearTib()
                    abortCompileNewWord()
                :if
            :if
        :if
        nextToken()
    :while
    endCompileNewWord()
;




